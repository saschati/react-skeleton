diff --git a/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js b/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js
index 441442f..f68a67f 100644
--- a/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js
+++ b/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js
@@ -177,8 +177,33 @@ var RulesOfHooks = {
     }
   },
   create: function (context) {
-    var codePathReactHooksMapStack = [];
-    var codePathSegmentStack = [];
+    let lastEffect = null;
+    const codePathReactHooksMapStack = [];
+    const codePathSegmentStack = [];
+    const useEffectEventFunctions = new WeakSet();
+
+    // For a given scope, iterate through the references and add all useEffectEvent definitions. We can
+    // do this in non-Program nodes because we can rely on the assumption that useEffectEvent functions
+    // can only be declared within a component or hook at its top level.
+    function recordAllUseEffectEventFunctions(scope) {
+      for (const reference of scope.references) {
+        const parent = reference.identifier.parent;
+        if (
+          parent.type === 'VariableDeclarator' &&
+          parent.init &&
+          parent.init.type === 'CallExpression' &&
+          parent.init.callee &&
+          isUseEffectEventIdentifier(parent.init.callee)
+        ) {
+          for (const ref of reference.resolved.references) {
+            if (ref !== reference) {
+              useEffectEventFunctions.add(ref.identifier);
+            }
+          }
+        }
+      }
+    }
+
     return {
       // Maintain code segment path stack as we traverse.
       onCodePathSegmentStart: function (segment) {
@@ -640,22 +665,72 @@ var RulesOfHooks = {
       // `CallExpression`s and check that _every use_ of a hook name is valid.
       // But that gets complicated and enters type-system territory, so we're
       // only being strict about hook calls for now.
-      CallExpression: function (node) {
+      CallExpression(node) {
         if (isHook(node.callee)) {
           // Add the hook node to a map keyed by the code path segment. We will
           // do full code path analysis at the end of our code path.
-          var reactHooksMap = last(codePathReactHooksMapStack);
-          var codePathSegment = last(codePathSegmentStack);
-          var reactHooks = reactHooksMap.get(codePathSegment);
-
+          const reactHooksMap = last(codePathReactHooksMapStack);
+          const codePathSegment = last(codePathSegmentStack);
+          let reactHooks = reactHooksMap.get(codePathSegment);
           if (!reactHooks) {
             reactHooks = [];
             reactHooksMap.set(codePathSegment, reactHooks);
           }
-
           reactHooks.push(node.callee);
         }
-      }
+
+        // useEffectEvent: useEffectEvent functions can be passed by reference within useEffect as well as in
+        // another useEffectEvent
+        if (
+          node.callee.type === 'Identifier' &&
+          (node.callee.name === 'useEffect' ||
+            isUseEffectEventIdentifier(node.callee)) &&
+          node.arguments.length > 0
+        ) {
+          // Denote that we have traversed into a useEffect call, and stash the CallExpr for
+          // comparison later when we exit
+          lastEffect = node;
+        }
+      },
+
+      Identifier(node) {
+        // This identifier resolves to a useEffectEvent function, but isn't being referenced in an
+        // effect or another event function. It isn't being called either.
+        if (
+          lastEffect == null &&
+          useEffectEventFunctions.has(node) &&
+          node.parent.type !== 'CallExpression'
+        ) {
+          context.report({
+            node,
+            message:
+              `\`${context.getSource(
+                node,
+              )}\` is a function created with React Hook "useEffectEvent", and can only be called from ` +
+              'the same component. They cannot be assigned to variables or passed down.',
+          });
+        }
+      },
+
+      'CallExpression:exit'(node) {
+        if (node === lastEffect) {
+          lastEffect = null;
+        }
+      },
+
+      FunctionDeclaration(node) {
+        // function MyComponent() { const onClick = useEffectEvent(...) }
+        if (isInsideComponentOrHook(node)) {
+          recordAllUseEffectEventFunctions(context.getScope());
+        }
+      },
+
+      ArrowFunctionExpression(node) {
+        // const MyComponent = () => { const onClick = useEffectEvent(...) }
+        if (isInsideComponentOrHook(node)) {
+          recordAllUseEffectEventFunctions(context.getScope());
+        }
+      },
     };
   }
 };
@@ -766,7 +841,7 @@ var ExhaustiveDeps = {
     var stateVariables = new WeakSet();
     var stableKnownValueCache = new WeakMap();
     var functionWithoutCapturedValueCache = new WeakMap();
-
+    var useEffectEventVariables = new WeakSet();
     function memoizeWithWeakMap(fn, map) {
       return function (arg) {
         if (map.has(arg)) {
@@ -836,6 +911,8 @@ var ExhaustiveDeps = {
       //               ^^^ true for this reference
       // const ref = useRef()
       //       ^^^ true for this reference
+      // const onStuff = useEffectEvent(() => {})
+      //       ^^^ true for this reference
       // False for everything else.
 
       function isStableKnownHookValue(resolved) {
@@ -908,6 +985,14 @@ var ExhaustiveDeps = {
         if (name === 'useRef' && id.type === 'Identifier') {
           // useRef() return value is stable.
           return true;
+        } else if (isUseEffectEventIdentifier(callee) && id.type === 'Identifier') {
+          for (const ref of resolved.references) {
+            if (ref !== id) {
+              useEffectEventVariables.add(ref.identifier);
+            }
+          }
+          // useEffectEvent() return value is always unstable.
+          return true;
         } else if (name === 'useState' || name === 'useReducer') {
           // Only consider second value in initializing tuple stable.
           if (id.type === 'ArrayPattern' && id.elements.length === 2 && isArray(resolved.identifiers)) {
@@ -1298,7 +1383,28 @@ var ExhaustiveDeps = {
               message: "React Hook " + context.getSource(reactiveHook) + " has a spread " + "element in its dependency array. This means we can't " + "statically verify whether you've passed the " + 'correct dependencies.'
             });
             return;
-          } // Try to normalize the declared dependency. If we can't then an error
+          }
+          if (useEffectEventVariables.has(declaredDependencyNode)) {
+            reportProblem({
+              node: declaredDependencyNode,
+              message:
+                'Functions returned from `useEffectEvent` must not be included in the dependency array. ' +
+                `Remove \`${context.getSource(
+                  declaredDependencyNode,
+                )}\` from the list.`,
+              suggest: [
+                {
+                  desc: `Remove the dependency \`${context.getSource(
+                    declaredDependencyNode,
+                  )}\``,
+                  fix(fixer) {
+                    return fixer.removeRange(declaredDependencyNode.range);
+                  },
+                },
+              ],
+            });
+          }
+          // Try to normalize the declared dependency. If we can't then an error
           // will be thrown. We will catch that error and report an error.
 
 
@@ -1859,6 +1965,10 @@ var ExhaustiveDeps = {
   }
 }; // The meat of the logic.
 
+function isUseEffectEventIdentifier(node) {
+  return node.type === 'Identifier' && node.name === 'useEffectEvent';;
+}
+
 function collectRecommendations(_ref6) {
   var dependencies = _ref6.dependencies,
       declaredDependencies = _ref6.declaredDependencies,
diff --git a/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.production.min.js b/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.production.min.js
index c9ee73a..1de11a0 100644
--- a/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.production.min.js
+++ b/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.production.min.js
@@ -7,57 +7,4 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-'use strict';function ca(a,c){if(a){if("string"===typeof a)return da(a,c);var b=Object.prototype.toString.call(a).slice(8,-1);"Object"===b&&a.constructor&&(b=a.constructor.name);if("Map"===b||"Set"===b)return Array.from(a);if("Arguments"===b||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(b))return da(a,c)}}function da(a,c){if(null==c||c>a.length)c=a.length;for(var b=0,d=Array(c);b<c;b++)d[b]=a[b];return d}
-function D(a,c){var b;if("undefined"===typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(b=ca(a))||c&&a&&"number"===typeof a.length){b&&(a=b);var d=0;c=function(){};return{s:c,n:function(){return d>=a.length?{done:!0}:{done:!1,value:a[d++]}},e:function(a){throw a;},f:c}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var f=!0,p=!1,g;return{s:function(){b=a[Symbol.iterator]()},
-n:function(){var a=b.next();f=a.done;return a},e:function(a){p=!0;g=a},f:function(){try{f||null==b.return||b.return()}finally{if(p)throw g;}}}}function G(a){if("Identifier"===a.type)return/^use[A-Z0-9].*$/.test(a.name);if("MemberExpression"===a.type&&!a.computed&&G(a.property)){a=a.object;var c=/^[A-Z].*/;return"Identifier"===a.type&&c.test(a.name)}return!1}function ea(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}
-function fa(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function ha(a){return!!(a.parent&&a.parent.callee&&fa(a.parent.callee,"forwardRef"))}function ia(a){return!!(a.parent&&a.parent.callee&&fa(a.parent.callee,"memo"))}function ma(a){for(;a;){var c=na(a);if(c&&(ea(c)||G(c))||ha(a)||ia(a))return!0;a=a.parent}return!1}
-function na(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
-a.parent.key}
-function H(a){function c(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function b(a,b){b=b.split(".");b=D(b);var h;try{for(b.s();!(h=b.n()).done;){var d=h.value,f=a.children.get(d);f||(f=c(),a.children.set(d,f));a=f}}catch(F){b.e(F)}finally{b.f()}return a}function d(a,c,b){c=c.split(".");c=D(c);var d;try{for(c.s();!(d=c.n()).done;){var h=a.children.get(d.value);if(!h)break;b(h);a=h}}catch(F){c.e(F)}finally{c.f()}}function f(a,c,b,d){a.children.forEach(function(a,h){var e=
-d(h);a.isSatisfiedRecursively?a.isSubtreeUsed&&b.add(e):a.isUsed?c.add(e):f(a,c,b,function(a){return e+"."+a})})}var p=a.dependencies,g=a.declaredDependencies,w=a.stableDependencies,m=a.externalDependencies,E=a.isEffect,x=c();p.forEach(function(a,c){b(x,c).isUsed=!0;d(x,c,function(a){a.isSubtreeUsed=!0})});g.forEach(function(a){b(x,a.key).isSatisfiedRecursively=!0});w.forEach(function(a){b(x,a).isSatisfiedRecursively=!0});a=new Set;var r=new Set;f(x,a,r,function(a){return a});var e=[],C=new Set,t=
-new Set;g.forEach(function(a){a=a.key;r.has(a)?-1===e.indexOf(a)?e.push(a):t.add(a):!E||a.endsWith(".current")||m.has(a)?C.add(a):-1===e.indexOf(a)&&e.push(a)});a.forEach(function(a){e.push(a)});return{suggestedDependencies:e,unnecessaryDependencies:C,duplicateDependencies:t,missingDependencies:a}}
-function Q(a){switch(a.type){case "ObjectExpression":return"object";case "ArrayExpression":return"array";case "ArrowFunctionExpression":case "FunctionExpression":return"function";case "ClassExpression":return"class";case "ConditionalExpression":if(null!=Q(a.consequent)||null!=Q(a.alternate))return"conditional";break;case "LogicalExpression":if(null!=Q(a.left)||null!=Q(a.right))return"logical expression";break;case "JSXFragment":return"JSX fragment";case "JSXElement":return"JSX element";case "AssignmentExpression":if(null!=
-Q(a.right))return"assignment expression";break;case "NewExpression":return"object construction";case "Literal":if(a.value instanceof RegExp)return"regular expression";break;case "TypeCastExpression":return Q(a.expression);case "TSAsExpression":return Q(a.expression)}return null}
-function oa(a){var c=a.declaredDependenciesNode,b=a.componentScope,d=a.scope;return a.declaredDependencies.map(function(a){var c=a.key;a=b.variables.find(function(a){return a.name===c});if(null==a)return null;var d=a.defs[0];if(null==d)return null;if("Variable"===d.type&&"VariableDeclarator"===d.node.type&&"Identifier"===d.node.id.type&&null!=d.node.init){var f=Q(d.node.init);if(null!=f)return[a,f]}return"FunctionName"===d.type&&"FunctionDeclaration"===d.node.type?[a,"function"]:"ClassName"===d.type&&
-"ClassDeclaration"===d.node.type?[a,"class"]:null}).filter(Boolean).map(function(a){var b=a[0];a=a[1];var f=b.defs[0];a:{for(var w=!1,m=0;m<b.references.length;m++){var E=b.references[m];if(E.writeExpr)if(w){b=!0;break a}else{w=!0;continue}for(var x=E.from;x!==d&&null!=x;)x=x.upper;if(x!==d&&!pa(c,E.identifier)){b=!0;break a}}b=!1}return{construction:f,depType:a,isUsedOutsideOfHook:b}})}
-function sa(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&("CallExpression"===a.parent.parent.type||"OptionalCallExpression"===a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:sa(a.parent)}
-function W(a,c,b){c&&(a.optional?c.has(b)||c.set(b,!0):c.set(b,!1))}
-function X(a,c){if("Identifier"===a.type||"JSXIdentifier"===a.type)return a=a.name,c&&c.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed){if("ChainExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);a=a.expression;if("CallExpression"===a.type)throw Error("Unsupported node type: "+a.type);var b=X(a.object,c),d=X(a.property,null);b=b+"."+d;W(a,c,b);return b}b=X(a.object,c);d=X(a.property,null);b=b+"."+d;W(a,c,b);return b}b=
-X(a.object,c);d=X(a.property,null);b=b+"."+d;W(a,c,b);return b}function ta(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
-function ua(a,c){var b=ta(a);if("Identifier"!==b.type)return-1;switch(b.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(b===a&&c&&c.additionalHooks){try{var d=X(b,null)}catch(f){if(/Unsupported node type/.test(f.message))return 0;throw f;}return c.additionalHooks.test(d)?0:-1}return-1}}
-function Y(a,c){for(var b=[a],d=null;b.length;){d=b.shift();if(("Identifier"===d.type||"JSXIdentifier"===d.type)&&d.type===c.type&&d.name===c.name&&d.range[0]===c.range[0]&&d.range[1]===c.range[1])return d;if(pa(d,c)){a=0;for(var f=Object.entries(d);a<f.length;a++){var p=f[a],g=p[1];"parent"!==p[0]&&(va(g)?(g.parent=d,b.push(g)):Array.isArray(g)&&g.forEach(function(a){va(a)&&(a.parent=d,b.push(a))}))}}}return null}
-function wa(a){for(var c="",b=0;b<a.length;b++)c+=a[b],0===b&&2===a.length?c+=" and ":b===a.length-2&&2<a.length?c+=", and ":b<a.length-1&&(c+=", ");return c}function va(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function pa(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
-exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){var c=[],b=[];return{onCodePathSegmentStart:function(a){return b.push(a)},onCodePathSegmentEnd:function(){return b.pop()},onCodePathStart:function(){return c.push(new Map)},onCodePathEnd:function(b,f){function d(a,c){var e=d.cache,f=e.get(a.id);c=new Set(c);if(c.has(a.id)){e=[].concat(c);a=e.slice(e.indexOf(a.id)+
-1);a=D(a);var l;try{for(a.s();!(l=a.n()).done;)E.add(l.value)}catch(u){a.e(u)}finally{a.f()}return BigInt("0")}c.add(a.id);if(void 0!==f)return f;if(b.thrownSegments.includes(a))f=BigInt("0");else if(0===a.prevSegments.length)f=BigInt("1");else{f=BigInt("0");l=D(a.prevSegments);var r;try{for(l.s();!(r=l.n()).done;)f+=d(r.value,c)}catch(u){l.e(u)}finally{l.f()}}a.reachable&&f===BigInt("0")?e.delete(a.id):e.set(a.id,f);return f}function g(a,c){var d=g.cache,e=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=
-Array.from(c);a=d.slice(d.indexOf(a.id)+1);a=D(a);var f;try{for(a.s();!(f=a.n()).done;)E.add(f.value)}catch(u){a.e(u)}finally{a.f()}return BigInt("0")}c.add(a.id);if(void 0!==e)return e;if(b.thrownSegments.includes(a))e=BigInt("0");else if(0===a.nextSegments.length)e=BigInt("1");else{e=BigInt("0");f=D(a.nextSegments);var r;try{for(f.s();!(r=f.n()).done;)e+=g(r.value,c)}catch(u){f.e(u)}finally{f.f()}}d.set(a.id,e);return e}function w(a){var c=w.cache,b=c.get(a.id);if(null===b)return Infinity;if(void 0!==
-b)return b;c.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var d=D(a.prevSegments),e;try{for(d.s();!(e=d.n()).done;){var f=w(e.value);f<b&&(b=f)}}catch(u){d.e(u)}finally{d.f()}b+=1}c.set(a.id,b);return b}var m=c.pop();if(0!==m.size){var E=new Set;d.cache=new Map;g.cache=new Map;w.cache=new Map;var x=g(b.initialSegment),r=na(f),e=ma(f),C=r?ea(r)||G(r):ha(f)||ia(f),t=Infinity,h=D(b.finalSegments),ja;try{for(h.s();!(ja=h.n()).done;){var ka=ja.value;if(ka.reachable){var la=w(ka);la<
-t&&(t=la)}}}catch(l){h.e(l)}finally{h.f()}m=D(m);var A;try{for(m.s();!(A=m.n()).done;){var F=A.value,q=F[0],B=F[1];if(q.reachable){var N=0===q.nextSegments.length?t<=w(q):t<w(q),T=d(q)*g(q),U=E.has(q.id),J=D(B),y;try{for(J.s();!(y=J.n()).done;){var z=y.value;U&&a.report({node:z,message:'React Hook "'+a.getSource(z)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(C){if(!U&&T!==x){var O='React Hook "'+
-a.getSource(z)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(N?" Did you accidentally call a React Hook after an early return?":"");a.report({node:z,message:O})}}else if(f.parent&&("MethodDefinition"===f.parent.type||"ClassProperty"===f.parent.type)&&f.parent.value===f){var M='React Hook "'+a.getSource(z)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';
-a.report({node:z,message:M})}else if(r){var K='React Hook "'+a.getSource(z)+'" is called in function "'+(a.getSource(r)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word "use".');a.report({node:z,message:K})}else if("Program"===f.type){var L='React Hook "'+a.getSource(z)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
-a.report({node:z,message:L})}else if(e){var n='React Hook "'+a.getSource(z)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:z,message:n})}}}catch(l){J.e(l)}finally{J.f()}}}}catch(l){m.e(l)}finally{m.f()}}},CallExpression:function(a){if(G(a.callee)){var d=c[c.length-1],p=b[b.length-1],g=d.get(p);g||(g=[],d.set(p,g));g.push(a.callee)}}}}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",
-recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",hasSuggestions:!0,schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function c(c){f&&Array.isArray(c.suggest)&&0<c.suggest.length&&(c.fix=c.suggest[0].fix);a.report(c)}function b(a,c){return function(b){if(c.has(b))return c.get(b);var d=
-a(b);c.set(b,d);return d}}function d(d,e,f,t,h){function r(a){var c=D(a.references),b;try{for(c.s();!(b=c.n()).done;){var k=b.value;if(k.resolved&&F.has(k.resolved.scope)){var f=Y(d,k.identifier),e=sa(f),g=X(e,z),t;if(t=h&&"Identifier"===e.type&&("MemberExpression"===e.parent.type||"OptionalMemberExpression"===e.parent.type)&&!e.parent.computed&&"Identifier"===e.parent.property.type&&"current"===e.parent.property.name){for(var l=k.from,n=!1;l.block!==d;)"function"===l.type&&(n=null!=l.block.parent&&
-"ReturnStatement"===l.block.parent.type),l=l.upper;t=n}t&&J.set(g,{reference:k,dependencyNode:e});if("TSTypeQuery"!==e.parent.type&&"TSTypeReference"!==e.parent.type){var C=k.resolved.defs[0];if(null!=C&&(null==C.node||C.node.init!==d.parent)&&"TypeParameter"!==C.type)if(y.has(g))y.get(g).references.push(k);else{var p=k.resolved,q=T(p)||U(p);y.set(g,{isStable:q,references:[k]})}}}}}catch(aa){c.e(aa)}finally{c.f()}a=D(a.childScopes);var m;try{for(a.s();!(m=a.n()).done;)r(m.value)}catch(aa){a.e(aa)}finally{a.f()}}
-function C(a){a=a.split(".");for(var c="",b=0;b<a.length;b++){if(0!==b){var k=a.slice(0,b+1).join(".");k=!0===z.get(k);c+=k?"?.":"."}c+=a[b]}return c}function p(a,c,b,d){return 0===a.size?null:(1<a.size?"":c+" ")+b+" "+(1<a.size?"dependencies":"dependency")+": "+wa(Array.from(a).sort().map(function(a){return"'"+C(a)+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}h&&d.async&&c({node:d,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});
-for(var A=g.acquire(d),F=new Set,q=null,B=A.upper;B;){F.add(B);if("function"===B.type)break;B=B.upper}if(B){q=B;var N=Array.isArray,T=b(function(a){if(!N(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var b=c.node.init;if(null==b)return!1;for(;"TSAsExpression"===b.type;)b=b.expression;var d=c.node.parent;if(null==d&&(Y(q.block,c.node.id),d=c.node.parent,null==d))return!1;if("const"===d.kind&&"Literal"===b.type&&("string"===typeof b.value||"number"===typeof b.value||
-null===b.value))return!0;if("CallExpression"!==b.type)return!1;b=b.callee;"MemberExpression"!==b.type||"React"!==b.object.name||null==b.property||b.computed||(b=b.property);if("Identifier"!==b.type)return!1;c=c.node.id;b=b.name;if("useRef"===b&&"Identifier"===c.type)return!0;if("useState"===b||"useReducer"===b){if("ArrayPattern"===c.type&&2===c.elements.length&&N(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===b)for(a=a.references,d=b=0;d<a.length;d++){a[d].isWrite()&&b++;if(1<
-b)return!1;w.set(a[d].identifier,c.elements[0])}return!0}if(c.elements[0]===a.identifiers[0]&&"useState"===b)for(a=a.references,c=0;c<a.length;c++)m.add(a[c].identifier)}}else if("useTransition"===b&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)&&c.elements[1]===a.identifiers[0])return!0;return!1},E),U=b(function(a){if(!N(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,b=q.childScopes;a=null;var d;for(d=0;d<b.length;d++){var e=
-b[d],k=e.block;if("FunctionDeclaration"===c.type&&k===c||"VariableDeclarator"===c.type&&k.parent===c){a=e;break}}if(null==a)return!1;for(d=0;d<a.through.length;d++)if(c=a.through[d],null!=c.resolved&&F.has(c.resolved.scope)&&!T(c.resolved))return!1;return!0},x),J=new Map,y=new Map,z=new Map;r(A);J.forEach(function(a,b){var d=a.dependencyNode;a=a.reference.resolved.references;for(var e=!1,f=0;f<a.length;f++){var k=a[f].identifier.parent;if(null!=k&&"MemberExpression"===k.type&&!k.computed&&"Identifier"===
-k.property.type&&"current"===k.property.name&&"AssignmentExpression"===k.parent.type&&k.parent.left===k){e=!0;break}}e||c({node:d.parent.property,message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var O=new Set,M=new Set;y.forEach(function(b,d){var e=b.references;b.isStable&&M.add(d);
-e.forEach(function(b){b.writeExpr&&(b=b.writeExpr,O.has(d)||(O.add(d),c({node:b,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(f)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+(a.getSource(f)+".")})))})});if(!(0<O.size))if(e){var K=[],L=new Set;"ArrayExpression"!==e.type?c({node:e,message:"React Hook "+a.getSource(f)+
-" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):e.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(f)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});else{try{var d=X(b,null)}catch(ra){if(/Unsupported node type/.test(ra.message)){"Literal"===b.type?
-y.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(f)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});return}throw ra;}for(var e=b;"MemberExpression"===
-e.type||"OptionalMemberExpression"===e.type||"ChainExpression"===e.type;)e=e.object||e.expression.object;var k=!q.through.some(function(a){return a.identifier===e});K.push({key:d,node:b});k||L.add(d)}});var n=H({dependencies:y,declaredDependencies:K,stableDependencies:M,externalDependencies:L,isEffect:h});B=n.unnecessaryDependencies;var l=n.missingDependencies,qa=n.duplicateDependencies,R=n.suggestedDependencies;if(0===qa.size+l.size+B.size)oa({declaredDependencies:K,declaredDependenciesNode:e,componentScope:q,
-scope:A}).forEach(function(a){var b=a.construction,d=a.isUsedOutsideOfHook;a=a.depType;var f="function"===a?"useCallback":"useMemo",k="function"===a?"definition":"initialization",h="wrap the "+k+" of '"+b.name.name+"' in its own "+f+"() Hook.";h="The '"+b.name.name+"' "+a+" "+("conditional"===a||"logical expression"===a?"could make":"makes")+" the dependencies of "+(t+" Hook (at line "+e.loc.start.line+") change on every render. ")+(d?"To fix this, "+h:"Move it inside the "+t+" callback. Alternatively, "+
-h);var g;d&&"Variable"===b.type&&"function"===a&&(g=[{desc:"Wrap the "+k+" of '"+b.name.name+"' in its own "+f+"() Hook.",fix:function(a){var c="useMemo"===f?["useMemo(() => { return ","; })"]:["useCallback(",")"],d=c[1];return[a.insertTextBefore(b.node.init,c[0]),a.insertTextAfter(b.node.init,d)]}}]);c({node:b.node,message:h,suggest:g})});else{!h&&0<l.size&&(R=H({dependencies:y,declaredDependencies:[],stableDependencies:M,externalDependencies:L,isEffect:h}).suggestedDependencies);(function(){if(0===
-K.length)return!0;var a=K.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&R.sort();n="";if(0<B.size){var S=null;Array.from(B.keys()).forEach(function(a){null===S&&a.endsWith(".current")&&(S=a)});if(null!==S)n=" Mutable values like '"+S+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<L.size){var I=Array.from(L)[0];A.set.has(I)||(n=" Outer scope values like '"+I+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!n&&
-l.has("props")){A=y.get("props");if(null==A)return;A=A.references;if(!Array.isArray(A))return;I=!0;for(var Z=0;Z<A.length;Z++){var u=Y(q.block,A[Z].identifier);if(!u){I=!1;break}u=u.parent;if(null==u){I=!1;break}if("MemberExpression"!==u.type&&"OptionalMemberExpression"!==u.type){I=!1;break}}I&&(n=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(t+" call and refer to those specific props inside ")+(a.getSource(f)+"."))}if(!n&&
-0<l.size){var V=null;l.forEach(function(a){if(!V){var b=q.set.get(a),c=y.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&("CallExpression"===d.parent.type||"OptionalCallExpression"===d.parent.type)&&d.parent.callee===d){b=!0;break}b&&(V=a)}}});null!==V&&(n=" If '"+V+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!n&&
-0<l.size){var v=null;l.forEach(function(a){if(null===v)for(var b=y.get(a).references,c,d,e=0;e<b.length;e++){c=b[e].identifier;for(d=c.parent;null!=d&&d!==q.block;){if("CallExpression"===d.type){var f=w.get(d.callee);if(null!=f){f.name===a?v={missingDep:a,setter:d.callee.name,form:"updater"}:m.has(c)?v={missingDep:a,setter:d.callee.name,form:"reducer"}:(c=b[e].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(v={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==
-v)break}});if(null!==v)switch(v.form){case "reducer":n=" You can also replace multiple useState variables with useReducer if '"+(v.setter+"' needs the current value of '")+(v.missingDep+"'.");break;case "inlineReducer":n=" If '"+v.setter+"' needs the current value of '"+(v.missingDep+"', you can also switch to useReducer instead of useState and read '")+(v.missingDep+"' in the reducer.");break;case "updater":n=" You can also do a functional update '"+v.setter+"("+v.missingDep.substring(0,1)+" => ...)' if you only need '"+
-v.missingDep+"' in the '"+(v.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:e,message:"React Hook "+a.getSource(f)+" has "+(p(l,"a","missing","include")||p(B,"an","unnecessary","exclude")||p(qa,"a","duplicate","omit"))+n,suggest:[{desc:"Update the dependencies array to be: ["+R.map(C).join(", ")+"]",fix:function(a){return a.replaceText(e,"["+R.map(C).join(", ")+"]")}}]})}}else{var P=null;y.forEach(function(a,b){P||a.references.forEach(function(a){if(!P&&w.has(a.identifier)){for(a=
-a.from;"function"!==a.type;)a=a.upper;a.block===d&&(P=b)}})});if(P){var ba=H({dependencies:y,declaredDependencies:[],stableDependencies:M,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;c({node:f,message:"React Hook "+t+" contains a call to '"+P+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ba.join(", ")+("] as a second argument to the "+t+" Hook."),suggest:[{desc:"Add dependencies array: ["+ba.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,
-", ["+ba.join(", ")+"]")}}]})}}}}var f=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,p={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:f},g=a.getSourceCode().scopeManager,w=new WeakMap,m=new WeakSet,E=new WeakMap,x=new WeakMap;return{CallExpression:function(b){var e=ua(b.callee,p);if(-1!==e){var f=b.arguments[e],g=b.callee,h=ta(g).name,
-m=b.arguments[e+1];b=/Effect($|[^a-z])/g.test(h);if(f)if(m||b){switch(f.type){case "FunctionExpression":case "ArrowFunctionExpression":d(f,m,g,h,b);return;case "Identifier":if(!m||m.elements&&m.elements.some(function(a){return a&&"Identifier"===a.type&&a.name===f.name}))return;e=a.getScope().set.get(f.name);if(null==e||null==e.defs)return;e=e.defs[0];if(!e||!e.node)break;if("Variable"!==e.type&&"FunctionName"!==e.type)break;switch(e.node.type){case "FunctionDeclaration":d(e.node,m,g,h,b);return;case "VariableDeclarator":if(e=
-e.node.init)switch(e.type){case "ArrowFunctionExpression":case "FunctionExpression":d(e,m,g,h,b);return}}break;default:c({node:g,message:"React Hook "+h+" received a function whose dependencies are unknown. Pass an inline function instead."});return}c({node:g,message:"React Hook "+h+" has a missing dependency: '"+f.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+f.name+"]",fix:function(a){return a.replaceText(m,"["+f.name+"]")}}]})}else"useMemo"!==
-h&&"useCallback"!==h||c({node:g,message:"React Hook "+h+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"});else c({node:g,message:"React Hook "+h+" requires an effect callback. Did you forget to pass a callback to the hook?"})}}}}}};
+'use strict';"production"!==process.env.NODE_ENV&&function(){'use strict';function e(e,i){if(e){if("string"==typeof e)return t(e,i);var s=Object.prototype.toString.call(e).slice(8,-1);return"Object"===s&&e.constructor&&(s=e.constructor.name),"Map"===s||"Set"===s?Array.from(e):"Arguments"===s||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)?t(e,i):void 0}}function t(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,s=Array(n);t<n;t++)s[t]=e[t];return s}function i(n,t){var s;if("undefined"==typeof Symbol||null==n[Symbol.iterator]){if(Array.isArray(n)||(s=e(n))||t&&n&&"number"==typeof n.length){s&&(n=s);var a=0,r=function(){};return{s:r,n:function(){return a>=n.length?{done:!0}:{done:!1,value:n[a++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var d,c=!0,p=!1;return{s:function(){s=n[Symbol.iterator]()},n:function(){var e=s.next();return c=e.done,e},e:function(n){p=!0,d=n},f:function(){try{c||null==s.return||s.return()}finally{if(p)throw d}}}}function s(e){return /^use[A-Z0-9].*$/.test(e)}function a(e){if("Identifier"===e.type)return s(e.name);if("MemberExpression"===e.type&&!e.computed&&a(e.property)){var n=e.object;return"Identifier"===n.type&&/^[A-Z].*/.test(n.name)}return!1}function r(e){return!("Identifier"!==e.type)&&!/^[a-z]/.test(e.name)}function o(e,n){return e.name===n||"MemberExpression"===e.type&&"React"===e.object.name&&e.property.name===n}function d(e){return!!(e.parent&&e.parent.callee&&o(e.parent.callee,"forwardRef"))}function c(e){return!!(e.parent&&e.parent.callee&&o(e.parent.callee,"memo"))}function p(e){for(;e;){var n=l(e);if(n&&(r(n)||a(n)))return!0;if(d(e)||c(e))return!0;e=e.parent}return!1}function l(e){return"FunctionDeclaration"===e.type||"FunctionExpression"===e.type&&e.id?e.id:"FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type?"VariableDeclarator"===e.parent.type&&e.parent.init===e?e.parent.id:"AssignmentExpression"===e.parent.type&&e.parent.right===e&&"="===e.parent.operator?e.parent.left:"Property"!==e.parent.type||e.parent.value!==e||e.parent.computed?"AssignmentPattern"!==e.parent.type||e.parent.right!==e||e.parent.computed?void 0:e.parent.left:e.parent.key:void 0}function u(e){return e[e.length-1]}function f(e){return"Identifier"===e.type&&"useEffectEvent"===e.name}function m(e){function n(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function t(e,t){var s,a=t.split("."),r=e,o=i(a);try{for(o.s();!(s=o.n()).done;){var d=s.value,c=r.children.get(d);c||(c=n(),r.children.set(d,c)),r=c}}catch(e){o.e(e)}finally{o.f()}return r}function s(e,n,t){var s,a=n.split("."),r=e,o=i(a);try{for(o.s();!(s=o.n()).done;){var d=s.value,c=r.children.get(d);if(!c)return;t(c),r=c}}catch(e){o.e(e)}finally{o.f()}}function a(e,n,t,i){e.children.forEach(function(e,s){var r=i(s);return e.isSatisfiedRecursively?void(e.isSubtreeUsed&&t.add(r)):e.isUsed?void n.add(r):void a(e,n,t,function(e){return r+"."+e})})}var r=e.dependencies,o=e.declaredDependencies,d=e.stableDependencies,c=e.externalDependencies,p=e.isEffect,l=n();r.forEach(function(e,n){var i=t(l,n);i.isUsed=!0,s(l,n,function(e){e.isSubtreeUsed=!0})}),o.forEach(function(e){var n=e.key,i=t(l,n);i.isSatisfiedRecursively=!0}),d.forEach(function(e){var n=t(l,e);n.isSatisfiedRecursively=!0});var u=new Set,f=new Set;a(l,u,f,function(e){return e});var m=[],h=new Set,y=new Set;return o.forEach(function(e){var n=e.key;f.has(n)?-1===m.indexOf(n)?m.push(n):y.add(n):!p||n.endsWith(".current")||c.has(n)?h.add(n):-1===m.indexOf(n)&&m.push(n)}),u.forEach(function(e){m.push(e)}),{suggestedDependencies:m,unnecessaryDependencies:h,duplicateDependencies:y,missingDependencies:u}}function h(e){switch(e.type){case"ObjectExpression":return"object";case"ArrayExpression":return"array";case"ArrowFunctionExpression":case"FunctionExpression":return"function";case"ClassExpression":return"class";case"ConditionalExpression":return null!=h(e.consequent)||null!=h(e.alternate)?"conditional":null;case"LogicalExpression":return null!=h(e.left)||null!=h(e.right)?"logical expression":null;case"JSXFragment":return"JSX fragment";case"JSXElement":return"JSX element";case"AssignmentExpression":return null==h(e.right)?null:"assignment expression";case"NewExpression":return"object construction";case"Literal":return e.value instanceof RegExp?"regular expression":null;case"TypeCastExpression":return h(e.expression);case"TSAsExpression":return h(e.expression);}return null}function y(e){function n(e){for(var n,t=!1,a=0;a<e.references.length;a++){if(n=e.references[a],n.writeExpr){if(t)return!0;t=!0;continue}for(var o=n.from;o!==r&&null!=o;)o=o.upper;if(o!==r&&!H(s,n.identifier))return!0}return!1}var t=e.declaredDependencies,s=e.declaredDependenciesNode,a=e.componentScope,r=e.scope,o=t.map(function(e){var n=e.key,t=a.variables.find(function(e){return e.name===n});if(null==t)return null;var i=t.defs[0];if(null==i)return null;if("Variable"===i.type&&"VariableDeclarator"===i.node.type&&"Identifier"===i.node.id.type&&null!=i.node.init){var s=h(i.node.init);if(null!=s)return[t,s]}return"FunctionName"===i.type&&"FunctionDeclaration"===i.node.type?[t,"function"]:"ClassName"===i.type&&"ClassDeclaration"===i.node.type?[t,"class"]:null}).filter(Boolean);return o.map(function(e){var t=e[0],i=e[1];return{construction:t.defs[0],depType:i,isUsedOutsideOfHook:n(t)}})}function g(e){return"MemberExpression"!==e.parent.type&&"OptionalMemberExpression"!==e.parent.type||e.parent.object!==e||"current"===e.parent.property.name||e.parent.computed||null!=e.parent.parent&&("CallExpression"===e.parent.parent.type||"OptionalCallExpression"===e.parent.parent.type)&&e.parent.parent.callee===e.parent?"MemberExpression"===e.type&&e.parent&&"AssignmentExpression"===e.parent.type&&e.parent.left===e?e.object:e:g(e.parent)}function b(e,n,t){n&&(e.optional?!n.has(t)&&n.set(t,!0):n.set(t,!1))}function x(e,n){if("Identifier"===e.type||"JSXIdentifier"===e.type){var t=e.name;return n&&n.set(t,!1),t}if("MemberExpression"===e.type&&!e.computed){var i=x(e.object,n),s=x(e.property,null),a=i+"."+s;return b(e,n,a),a}if("OptionalMemberExpression"===e.type&&!e.computed){var r=x(e.object,n),o=x(e.property,null),d=r+"."+o;return b(e,n,d),d}if("ChainExpression"===e.type&&!e.computed){var c=e.expression;if("CallExpression"===c.type)throw new Error("Unsupported node type: "+c.type);var p=x(c.object,n),l=x(c.property,null),u=p+"."+l;return b(c,n,u),u}throw new Error("Unsupported node type: "+e.type)}function E(e){return"MemberExpression"!==e.type||"Identifier"!==e.object.type||"React"!==e.object.name||"Identifier"!==e.property.type||e.computed?e:e.property}function v(e,n){var t=E(e);if("Identifier"!==t.type)return-1;switch(t.name){case"useEffect":case"useLayoutEffect":case"useCallback":case"useMemo":return 0;case"useImperativeHandle":return 1;default:if(t===e&&n&&n.additionalHooks){var i;try{i=x(t,null)}catch(e){if(/Unsupported node type/.test(e.message))return 0;throw e}return n.additionalHooks.test(i)?0:-1}return-1;}}function k(e,n){for(var t=[e],i=null;t.length;){if(i=t.shift(),R(i,n))return i;if(H(i,n))for(var s=0,a=Object.entries(i);s<a.length;s++){var r=a[s],o=r[0],d=r[1];"parent"!==o&&(D(d)?(d.parent=i,t.push(d)):Array.isArray(d)&&d.forEach(function(e){D(e)&&(e.parent=i,t.push(e))}))}}return null}function S(e){for(var n="",t=0;t<e.length;t++)n+=e[t],0==t&&2===e.length?n+=" and ":t===e.length-2&&2<e.length?n+=", and ":t<e.length-1&&(n+=", ");return n}function D(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&"string"==typeof e.type}function R(e,n){return("Identifier"===e.type||"JSXIdentifier"===e.type)&&e.type===n.type&&e.name===n.name&&e.range[0]===n.range[0]&&e.range[1]===n.range[1]}function H(e,n){return e.range[0]<=n.range[0]&&e.range[1]>=n.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}},exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(e){function n(e){for(const n of e.references){const e=n.identifier.parent;if("VariableDeclarator"===e.type&&e.init&&"CallExpression"===e.init.type&&e.init.callee&&f(e.init.callee))for(const e of n.resolved.references)e!==n&&m.add(e.identifier)}}let t=null;const s=[],o=[],m=new WeakSet;return{onCodePathSegmentStart:function(e){return o.push(e)},onCodePathSegmentEnd:function(){return o.pop()},onCodePathStart:function(){return s.push(new Map)},onCodePathEnd:function(n,t){function o(e,t){var s=o.cache,a=s.get(e.id),r=new Set(t);if(r.has(e.id)){var d,c=[].concat(r),p=c.slice(c.indexOf(e.id)+1),l=i(p);try{for(l.s();!(d=l.n()).done;){var u=d.value;h.add(u)}}catch(e){l.e(e)}finally{l.f()}return BigInt("0")}if(r.add(e.id),void 0!==a)return a;if(n.thrownSegments.includes(e))a=BigInt("0");else if(0===e.prevSegments.length)a=BigInt("1");else{a=BigInt("0");var f,m=i(e.prevSegments);try{for(m.s();!(f=m.n()).done;){var y=f.value;a+=o(y,r)}}catch(e){m.e(e)}finally{m.f()}}return e.reachable&&a===BigInt("0")?s.delete(e.id):s.set(e.id,a),a}function u(e,t){var s=u.cache,a=s.get(e.id),r=new Set(t);if(r.has(e.id)){var o,d=Array.from(r),c=d.slice(d.indexOf(e.id)+1),p=i(c);try{for(p.s();!(o=p.n()).done;){var l=o.value;h.add(l)}}catch(e){p.e(e)}finally{p.f()}return BigInt("0")}if(r.add(e.id),void 0!==a)return a;if(n.thrownSegments.includes(e))a=BigInt("0");else if(0===e.nextSegments.length)a=BigInt("1");else{a=BigInt("0");var f,m=i(e.nextSegments);try{for(m.s();!(f=m.n()).done;){var y=f.value;a+=u(y,r)}}catch(e){m.e(e)}finally{m.f()}}return s.set(e.id,a),a}function f(e){var n=f.cache,t=n.get(e.id);if(null===t)return 1/0;if(void 0!==t)return t;if(n.set(e.id,null),0===e.prevSegments.length)t=1;else{t=1/0;var s,a=i(e.prevSegments);try{for(a.s();!(s=a.n()).done;){var r=s.value,o=f(r);o<t&&(t=o)}}catch(e){a.e(e)}finally{a.f()}t+=1}return n.set(e.id,t),t}var m=s.pop();if(0!==m.size){var h=new Set;o.cache=new Map,u.cache=new Map,f.cache=new Map;var y,g=u(n.initialSegment),b=l(t),x=p(t),E=b?r(b)||a(b):d(t)||c(t),v=1/0,k=i(n.finalSegments);try{for(k.s();!(y=k.n()).done;){var S=y.value;if(S.reachable){var D=f(S);D<v&&(v=D)}}}catch(e){k.e(e)}finally{k.f()}var R,H=i(m);try{for(H.s();!(R=H.n()).done;){var w=R.value,I=w[0],A=w[1];if(I.reachable){var C,M=0===I.nextSegments.length?v<=f(I):v<f(I),j=o(I)*u(I),T=h.has(I.id),O=i(A);try{for(O.s();!(C=O.n()).done;){var P=C.value;if(T&&e.report({node:P,message:"React Hook \""+e.getSource(P)+"\" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render."}),E){if(!T&&j!==g){var F="React Hook \""+e.getSource(P)+"\" is called conditionally. React Hooks must be called in the exact same order in every component render."+(M?" Did you accidentally call a React Hook after an early return?":"");e.report({node:P,message:F})}}else if(t.parent&&("MethodDefinition"===t.parent.type||"ClassProperty"===t.parent.type)&&t.parent.value===t){var z="React Hook \""+e.getSource(P)+"\" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.";e.report({node:P,message:z})}else if(b){var U="React Hook \""+e.getSource(P)+"\" is called in "+("function \""+e.getSource(b)+"\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".");e.report({node:P,message:U})}else if("Program"===t.type){var L="React Hook \""+e.getSource(P)+"\" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.";e.report({node:P,message:L})}else if(x){var N="React Hook \""+e.getSource(P)+"\" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.";e.report({node:P,message:N})}}}catch(e){O.e(e)}finally{O.f()}}}}catch(e){H.e(e)}finally{H.f()}}},CallExpression(e){if(a(e.callee)){const n=u(s),t=u(o);let i=n.get(t);i||(i=[],n.set(t,i)),i.push(e.callee)}"Identifier"===e.callee.type&&("useEffect"===e.callee.name||f(e.callee))&&0<e.arguments.length&&(t=e)},Identifier(n){null==t&&m.has(n)&&"CallExpression"!==n.parent.type&&e.report({node:n,message:`\`${e.getSource(n)}\` is a function created with React Hook "useEffectEvent", and can only be called from `+"the same component. They cannot be assigned to variables or passed down."})},"CallExpression:exit"(e){e===t&&(t=null)},FunctionDeclaration(t){p(t)&&n(e.getScope())},ArrowFunctionExpression(t){p(t)&&n(e.getScope())}}}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",hasSuggestions:!0,schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(e){function n(n){r&&Array.isArray(n.suggest)&&0<n.suggest.length&&(n.fix=n.suggest[0].fix),e.report(n)}function t(e,n){return function(t){if(n.has(t))return n.get(t);var i=e(t);return n.set(t,i),i}}function s(s,a,r,o,b){function E(e){if(!O(e.defs))return!1;var n=e.defs[0];if(null==n)return!1;if("VariableDeclarator"!==n.node.type)return!1;var t=n.node.init;if(null==t)return!1;for(;"TSAsExpression"===t.type;)t=t.expression;var s=n.node.parent;if(null==s&&(k(j.block,n.node.id),s=n.node.parent,null==s))return!1;if("const"===s.kind&&"Literal"===t.type&&("string"==typeof t.value||"number"==typeof t.value||null===t.value))return!0;if("CallExpression"!==t.type)return!1;var a=t.callee;if("MemberExpression"!==a.type||"React"!==a.object.name||null==a.property||a.computed||(a=a.property),"Identifier"!==a.type)return!1;var r=n.node.id,o=a,d=o.name;if("useRef"===d&&"Identifier"===r.type)return!0;if(f(a)&&"Identifier"===r.type){for(const n of e.references)n!==r&&h.add(n.identifier);return!0}if("useState"===d||"useReducer"===d){if("ArrayPattern"===r.type&&2===r.elements.length&&O(e.identifiers)){if(r.elements[1]===e.identifiers[0]){if("useState"===d)for(var l=e.references,u=0,m=0;m<l.length;m++){if(l[m].isWrite()&&u++,1<u)return!1;c.set(l[m].identifier,r.elements[0])}return!0}if(r.elements[0]===e.identifiers[0]){if("useState"===d)for(var y=e.references,g=0;g<y.length;g++)p.add(y[g].identifier);return!1}}}else if("useTransition"===d&&"ArrayPattern"===r.type&&2===r.elements.length&&Array.isArray(e.identifiers)&&r.elements[1]===e.identifiers[0])return!0;return!1}function v(e){if(!O(e.defs))return!1;var n=e.defs[0];if(null==n)return!1;if(null==n.node||null==n.node.id)return!1;var t,s=n.node,a=j.childScopes,r=null;for(t=0;t<a.length;t++){var o=a[t],d=o.block;if("FunctionDeclaration"===s.type&&d===s||"VariableDeclarator"===s.type&&d.parent===s){r=o;break}}if(null==r)return!1;for(t=0;t<r.through.length;t++){var c=r.through[t];if(null!=c.resolved&&M.has(c.resolved.scope)&&!P(c.resolved))return!1}return!0}function D(e){for(var n=e.from,t=!1;n.block!==s;)"function"===n.type&&(t=null!=n.block.parent&&"ReturnStatement"===n.block.parent.type),n=n.upper;return t}function R(e){var n,t=i(e.references);try{for(t.s();!(n=t.n()).done;){var a=n.value;if(a.resolved&&M.has(a.resolved.scope)){var r=k(s,a.identifier),o=g(r),d=x(o,L);if(b&&"Identifier"===o.type&&("MemberExpression"===o.parent.type||"OptionalMemberExpression"===o.parent.type)&&!o.parent.computed&&"Identifier"===o.parent.property.type&&"current"===o.parent.property.name&&D(a)&&z.set(d,{reference:a,dependencyNode:o}),"TSTypeQuery"!==o.parent.type&&"TSTypeReference"!==o.parent.type){var c=a.resolved.defs[0];if(null!=c&&(null==c.node||c.node.init!==s.parent)&&"TypeParameter"!==c.type)if(!U.has(d)){var p=a.resolved,l=P(p)||F(p);U.set(d,{isStable:l,references:[a]})}else U.get(d).references.push(a)}}}}catch(e){t.e(e)}finally{t.f()}var u,f=i(e.childScopes);try{for(f.s();!(u=f.n()).done;){var m=u.value;R(m)}}catch(e){f.e(e)}finally{f.f()}}function H(t,i){N.has(i)||(N.add(i),n({node:t,message:"Assignments to the '"+i+"' variable from inside React Hook "+(e.getSource(r)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+(e.getSource(r)+".")}))}function w(){if(0===W.length)return!0;var e=W.map(function(e){return e.key}),n=e.slice().sort();return e.join(",")===n.join(",")}function I(e){for(var n=e.split("."),t="",s=0;s<n.length;s++){if(0!=s){var a=n.slice(0,s+1).join("."),r=!0===L.get(a);t+=r?"?.":"."}t+=n[s]}return t}function A(e,n,t,i){return 0===e.size?null:(1<e.size?"":n+" ")+t+" "+(1<e.size?"dependencies":"dependency")+": "+S(Array.from(e).sort().map(function(e){return"'"+I(e)+"'"}))+(". Either "+i+" "+(1<e.size?"them":"it")+" or remove the dependency array.")}b&&s.async&&n({node:s,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});var C=d.acquire(s),M=new Set,j=null;{for(var T=C.upper;T&&(M.add(T),"function"!==T.type);)T=T.upper;if(!T)return;j=T}var O=Array.isArray,P=t(E,l),F=t(v,u),z=new Map,U=new Map,L=new Map;R(C),z.forEach(function(e,t){for(var s=e.reference,a=e.dependencyNode,r=s.resolved.references,o=!1,d=0;d<r.length;d++){var c=r[d].identifier,p=c.parent;if(null!=p&&"MemberExpression"===p.type&&!p.computed&&"Identifier"===p.property.type&&"current"===p.property.name&&"AssignmentExpression"===p.parent.type&&p.parent.left===p){o=!0;break}}o||n({node:a.parent.property,message:"The ref value '"+t+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy "+("'"+t+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var N=new Set,V=new Set;if(U.forEach(function(e,n){var t=e.isStable,i=e.references;t&&V.add(n),i.forEach(function(e){e.writeExpr&&H(e.writeExpr,n)})}),!(0<N.size)){if(!a){var J=null;if(U.forEach(function(e,n){var t=e.isStable,i=e.references;J||i.forEach(function(e){if(!J){var t=e.identifier,i=c.has(t);if(i){for(var a=e.from;"function"!==a.type;)a=a.upper;var r=a.block===s;r&&(J=n)}}})}),J){var X=m({dependencies:U,declaredDependencies:[],stableDependencies:V,externalDependencies:new Set,isEffect:!0}),_=X.suggestedDependencies;n({node:r,message:"React Hook "+o+" contains a call to '"+J+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+_.join(", ")+("] as a second argument to the "+o+" Hook."),suggest:[{desc:"Add dependencies array: ["+_.join(", ")+"]",fix:function(e){return e.insertTextAfter(s,", ["+_.join(", ")+"]")}}]})}return}var W=[],Y=new Set;"ArrayExpression"===a.type?a.elements.forEach(function(t){if(null!==t){if("SpreadElement"===t.type)return void n({node:t,message:"React Hook "+e.getSource(r)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});h.has(t)&&n({node:t,message:"Functions returned from `useEffectEvent` must not be included in the dependency array. "+`Remove \`${e.getSource(t)}\` from the list.`,suggest:[{desc:`Remove the dependency \`${e.getSource(t)}\``,fix(e){return e.removeRange(t.range)}}]});var i;try{i=x(t,null)}catch(i){if(/Unsupported node type/.test(i.message))return void("Literal"===t.type?U.has(t.value)?n({node:t,message:"The "+t.raw+" literal is not a valid dependency because it never changes. "+("Did you mean to include "+t.value+" in the array instead?")}):n({node:t,message:"The "+t.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):n({node:t,message:"React Hook "+e.getSource(r)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."}));throw i}for(var s=t;"MemberExpression"===s.type||"OptionalMemberExpression"===s.type||"ChainExpression"===s.type;)s=s.object||s.expression.object;var a=!j.through.some(function(e){return e.identifier===s});W.push({key:i,node:t}),a||Y.add(i)}}):n({node:a,message:"React Hook "+e.getSource(r)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."});var q=m({dependencies:U,declaredDependencies:W,stableDependencies:V,externalDependencies:Y,isEffect:b}),B=q.suggestedDependencies,Q=q.unnecessaryDependencies,G=q.missingDependencies,K=q.duplicateDependencies,Z=B,$=K.size+G.size+Q.size;if(0===$){var ee=y({declaredDependencies:W,declaredDependenciesNode:a,componentScope:j,scope:C});return void ee.forEach(function(e){var t,i=e.construction,s=e.isUsedOutsideOfHook,r=e.depType,d="function"===r?"useCallback":"useMemo",c="function"===r?"definition":"initialization",p="wrap the "+c+" of '"+i.name.name+"' in its own "+d+"() Hook.",l=s?"To fix this, "+p:"Move it inside the "+o+" callback. Alternatively, "+p,u="conditional"===r||"logical expression"===r?"could make":"makes",f="The '"+i.name.name+"' "+r+" "+u+" the dependencies of "+(o+" Hook (at line "+a.loc.start.line+") ")+("change on every render. "+l);s&&"Variable"===i.type&&"function"===r&&(t=[{desc:"Wrap the "+c+" of '"+i.name.name+"' in its own "+d+"() Hook.",fix:function(e){var n="useMemo"===d?["useMemo(() => { return ","; })"]:["useCallback(",")"],t=n[0],s=n[1];return[e.insertTextBefore(i.node.init,t),e.insertTextAfter(i.node.init,s)]}}]),n({node:i.node,message:f,suggest:t})})}!b&&0<G.size&&(Z=m({dependencies:U,declaredDependencies:[],stableDependencies:V,externalDependencies:Y,isEffect:b}).suggestedDependencies),w()&&Z.sort();var ne="";if(0<Q.size){var te=null;if(Array.from(Q.keys()).forEach(function(e){null!==te||e.endsWith(".current")&&(te=e)}),null!==te)ne=" Mutable values like '"+te+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<Y.size){var ie=Array.from(Y)[0];C.set.has(ie)||(ne=" Outer scope values like '"+ie+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!ne&&G.has("props")){var se=U.get("props");if(null==se)return;var ae=se.references;if(!Array.isArray(ae))return;for(var re=!0,oe=0;oe<ae.length;oe++){var de=ae[oe],ce=k(j.block,de.identifier);if(!ce){re=!1;break}var pe=ce.parent;if(null==pe){re=!1;break}if("MemberExpression"!==pe.type&&"OptionalMemberExpression"!==pe.type){re=!1;break}}re&&(ne=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+o+" call and refer to those specific props "+("inside "+e.getSource(r)+"."))}if(!ne&&0<G.size){var le=null;G.forEach(function(e){if(!le){var n=j.set.get(e),t=U.get(e);if(t.references[0].resolved===n){var i=n.defs[0];if(null!=i&&null!=i.name&&"Parameter"===i.type){for(var s,a=!1,r=0;r<t.references.length;r++)if(s=t.references[r].identifier,null!=s&&null!=s.parent&&("CallExpression"===s.parent.type||"OptionalCallExpression"===s.parent.type)&&s.parent.callee===s){a=!0;break}a&&(le=e)}}}}),null!==le&&(ne=" If '"+le+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!ne&&0<G.size){var ue=null;if(G.forEach(function(e){if(null===ue)for(var n,t,i=U.get(e),s=i.references,a=0;a<s.length;a++){for(n=s[a].identifier,t=n.parent;null!=t&&t!==j.block;){if("CallExpression"===t.type){var r=c.get(t.callee);if(null!=r){if(r.name===e)ue={missingDep:e,setter:t.callee.name,form:"updater"};else if(p.has(n))ue={missingDep:e,setter:t.callee.name,form:"reducer"};else{var o=s[a].resolved;if(null!=o){var d=o.defs[0];null!=d&&"Parameter"===d.type&&(ue={missingDep:e,setter:t.callee.name,form:"inlineReducer"})}}break}}t=t.parent}if(null!==ue)break}}),null!==ue)switch(ue.form){case"reducer":ne=" You can also replace multiple useState variables with useReducer if '"+ue.setter+"' needs the "+("current value of '"+ue.missingDep+"'.");break;case"inlineReducer":ne=" If '"+ue.setter+"' needs the "+("current value of '"+ue.missingDep+"', you can also switch to useReducer instead of useState and ")+("read '"+ue.missingDep+"' in the reducer.");break;case"updater":ne=" You can also do a functional update '"+ue.setter+"("+ue.missingDep.substring(0,1)+" => ...)' if you only need '"+ue.missingDep+"'"+(" in the '"+ue.setter+"' call.");break;default:throw new Error("Unknown case.");}}n({node:a,message:"React Hook "+e.getSource(r)+" has "+(A(G,"a","missing","include")||A(Q,"an","unnecessary","exclude")||A(K,"a","duplicate","omit"))+ne,suggest:[{desc:"Update the dependencies array to be: ["+Z.map(I).join(", ")+"]",fix:function(e){return e.replaceText(a,"["+Z.map(I).join(", ")+"]")}}]})}}var a=e.options&&e.options[0]&&e.options[0].additionalHooks?new RegExp(e.options[0].additionalHooks):void 0,r=e.options&&e.options[0]&&e.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,o={additionalHooks:a,enableDangerousAutofixThisMayCauseInfiniteLoops:r},d=e.getSourceCode().scopeManager,c=new WeakMap,p=new WeakSet,l=new WeakMap,u=new WeakMap,h=new WeakSet;return{CallExpression:function(t){var i=v(t.callee,o);if(-1!==i){var a=t.arguments[i],r=t.callee,d=E(r).name,c=t.arguments[i+1],p=/Effect($|[^a-z])/g.test(d);if(!a)return void n({node:r,message:"React Hook "+d+" requires an effect callback. Did you forget to pass a callback to the hook?"});if(!c&&!p)return void(("useMemo"===d||"useCallback"===d)&&n({node:r,message:"React Hook "+d+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"}));switch(a.type){case"FunctionExpression":case"ArrowFunctionExpression":return void s(a,c,r,d,p);case"Identifier":if(!c)return;if(c.elements&&c.elements.some(function(e){return e&&"Identifier"===e.type&&e.name===a.name}))return;var l=e.getScope().set.get(a.name);if(null==l||null==l.defs)return;var u=l.defs[0];if(!u||!u.node)break;if("Variable"!==u.type&&"FunctionName"!==u.type)break;switch(u.node.type){case"FunctionDeclaration":return void s(u.node,c,r,d,p);case"VariableDeclarator":var f=u.node.init;if(!f)break;switch(f.type){case"ArrowFunctionExpression":case"FunctionExpression":return void s(f,c,r,d,p);}}break;default:return void n({node:r,message:"React Hook "+d+" received a function whose dependencies are unknown. Pass an inline function instead."});}n({node:r,message:"React Hook "+d+" has a missing dependency: '"+a.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+a.name+"]",fix:function(e){return e.replaceText(c,"["+a.name+"]")}}]})}}}}}}}();
\ No newline at end of file
